<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./css/test11.css">
    <title>Document</title>

</head>
<body>
    <div class="liaotian">
        <ul></ul>
    </div>
    <div class="bottom-box">
      <div class="text"><textarea placeholder="告诉我你想知道什么"></textarea>
    <button onclick="getValue()"><svg width="14" height="16" viewBox="0 0 14 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 16c-.595 0-1.077-.462-1.077-1.032V1.032C5.923.462 6.405 0 7 0s1.077.462 1.077 1.032v13.936C8.077 15.538 7.595 16 7 16z" fill="currentColor"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M.315 7.44a1.002 1.002 0 0 1 0-1.46L6.238.302a1.11 1.11 0 0 1 1.523 0c.421.403.421 1.057 0 1.46L1.838 7.44a1.11 1.11 0 0 1-1.523 0z" fill="currentColor"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M13.685 7.44a1.11 1.11 0 0 1-1.523 0L6.238 1.762a1.002 1.002 0 0 1 0-1.46 1.11 1.11 0 0 1 1.523 0l5.924 5.678c.42.403.42 1.056 0 1.46z" fill="currentColor"></path></svg></button></div>
    </div>
</body>
<script>
 var ul = document.querySelector('.liaotian ul');
var text = document.querySelector('textarea');

function getValue() {
    var value = document.querySelector('textarea').value;
    if (!value.trim()) return; // 如果输入为空则不发送
    
    const url = 'https://api.siliconflow.cn/v1/chat/completions';
    const apiKey = 'sk-epttdgplwzbhjcyeqioommvxzpxarpooxpyvsisyrtjbpthv';
    
    // 添加用户消息
    ul.innerHTML += `<li class="user"><span>${value}</span></li>`;
    text.value = '';
    scrollToBottom(); // 发送后立即滚动
    
    // 创建AI回复的li元素
    const aiLi = document.createElement('li');
    aiLi.className = 'Ai';
    aiLi.innerHTML = '<span class="typing-cursor">|</span>';
    ul.appendChild(aiLi);
    scrollToBottom(); // 添加AI回复容器后滚动
    
    const requestData = {
        model: "Qwen/QwQ-32B",
        messages: [{ role: "user", content: `${value}` }],
        max_tokens: 1000,
        temperature: 0.7,
        stream: true
    };

    fetch(url, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestData)
    })
    .then(async (response) => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullResponse = '';
        let buffer = '';
        
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\n');
            buffer = lines.pop();
            
            for (const line of lines) {
                if (line.trim() === '') continue;
                const message = line.replace(/^data: /, '');
                if (message === '[DONE]') {
                    aiLi.querySelector('.typing-cursor')?.remove();
                    return;
                }
                
                try {
                    const parsed = JSON.parse(message);
                    const content = parsed.choices[0]?.delta?.content || '';
                    if (content) {
                        fullResponse += content;
                        aiLi.innerHTML = `<span>${fullResponse}</span><span class="typing-cursor">|</span>`;
                        scrollToBottom(); // 每次更新内容后滚动
                    }
                } catch (err) {
                    console.error('Error parsing message:', err);
                }
            }
        }
    })
    .catch(error => {
        console.error('Error:', error);
        aiLi.innerHTML = `<span style="color: red;">请求出错: ${error.message}</span>`;
        scrollToBottom();
    });
}

// 自动滚动函数
function scrollToBottom() {
    var ul = document.querySelector('.liaotian ul');
    // 使用requestAnimationFrame确保在DOM更新后执行
    requestAnimationFrame(() => {
        ul.scrollTop = ul.scrollHeight;
        // 如果需要平滑滚动，可以使用以下替代方案：
        // ul.scrollTo({ top: ul.scrollHeight, behavior: 'smooth' });
    });
}

// 添加CSS样式
const style = document.createElement('style');
style.textContent = `
    .liaotian ul {
        overflow-y: auto;
        max-height: 80vh; /* 设置最大高度 */
    }
    .typing-cursor {
        animation: blink 1s infinite;
    }
    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
    }
`;
document.head.appendChild(style);
</script>
<script src="./js/reset.js"></script>
</html>